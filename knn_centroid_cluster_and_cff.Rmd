---
title: "Optimized Mood-Based Collaborative Filtering"
output: html_notebook
date: "2025-12-05"
editor_options:
  markdown:
    wrap: 72
---

### 1. Setup and Data Preprocessing

Load libraries, clean the data, and prepare the feature matrix.

```{r}
library(tidyverse)

df <- read.csv("spotify_data.csv") %>%
  distinct(track_name, artists, .keep_all = TRUE) %>%
  drop_na()
```

```{r}
# Feature Selection
emotion_feats <- df %>%
  select(
    danceability, energy, key, loudness, mode,
    speechiness, acousticness, instrumentalness,
    liveness, valence, tempo
  )

scaled_feats <- scale(emotion_feats)
```

```{r}
# Define Feature weights
weights <- c(
  danceability = 2,
  energy = 3,
  key = 0.2,
  loudness = 1,
  mode = 0.2,
  speechiness = 2,
  acousticness = 1,
  instrumentalness = 1,
  liveness = 2,
  valence = 2,
  tempo = 1
)


# Apply weights
weighted_feats <- scaled_feats %*% diag(weights)
```

```{r}
# Normalize weighted features to unit vectors (for cosine similarity)
row_norms <- sqrt(rowSums(weighted_feats^2))
row_norms[row_norms == 1e-8] <- 1e-8 
norm_feats <- weighted_feats / row_norms
```

```{r}
# K-Means Clustering
set.seed(42)
k <- 4
km <- kmeans(weighted_feats, centers = k, nstart = 50)

df$emotion_cluster <- km$cluster
```

```{r}

cluster_summary <- df %>%
  group_by(emotion_cluster) %>%
  summarise(
    n = n(),
    across(danceability:tempo, mean),
    .groups = "drop"
  )

print(cluster_summary)
```

```{r}

# Manual mapping based on assumed cluster analysis
manual_map <- c(
  "1" = "happy",
  "2" = "angry",
  "3" = "sad",
  "4" = "neutral"
)

df$emotion_label <- manual_map[as.character(df$emotion_cluster)]
```


```{r}

# Centroid Score Computation (rating)
compute_centroid_scores <- function(mood_label) {
  idx <- which(df$emotion_label == mood_label)
  if (length(idx) == 0) {
    stop(paste("No songs found for mood:", mood_label))
  }
  
  # Normalize 
  centroid <- colMeans(weighted_feats[idx, , drop = FALSE])
  c_norm <- sqrt(sum(centroid^2))
  if (c_norm == 0) c_norm <- 1e-8
  centroid_unit <- centroid / c_norm
  
  # Compute cosine similarity (centroid Score)
  scores <- as.numeric(norm_feats %*% centroid_unit)
  scores[is.na(scores)] <- 0
  return(scores)
}
```

```{r}
# Cal score for the target mood and assigns rank.
get_full_centroid_info <- function(mood_label) {
  # Calculate Centroid Scores for all songs
  centroid_scores <- compute_centroid_scores(mood_label)
  
  temp_df <- data.frame(
    original_centroid_score = centroid_scores
  ) %>%
    # Raw ranking
    mutate(
      rank_before_cf = rank(desc(original_centroid_score), ties.method = "min")
    )
  
  return(temp_df)
}
```


```{r}
predict_cf_for_song <- function(j, r_vec, k_neighbors = 50) {
  sims <- as.numeric(norm_feats %*% norm_feats[j, ]) 
  sims[j] <- 0 # Exclude itself
  
  # Selecting knn
  k_neighbors <- min(k_neighbors, length(sims) - 1)
  top_idx <- order(sims, decreasing = TRUE)[1:k_neighbors]
  
  sims_k <- sims[top_idx]
  r_k    <- r_vec[top_idx] 
  
  # Weighted average (CF formula)
  num <- sum(r_k * sims_k)
  den <- sum(abs(sims_k))
  
  if (den == 0) return(r_vec[j]) # Fallback
  return(num / den)
}
```

```{r}
compute_cf_scores <- function(mood_label, k_neighbors = 50) {
  # Load the xentroid Score vector (ratings)
  r_vec <- compute_centroid_scores(mood_label)
  N <- nrow(df)
  
  cf_scores <- numeric(N)
  
  # Progress bar
  print(paste("Calculating CF Scores for:", mood_label))
  pb <- utils::txtProgressBar(min = 1, max = N, style = 3)
  
  for (j in 1:N) {
    # Calculate CF Score
    cf_scores[j] <- predict_cf_for_song(j, r_vec, k_neighbors)
    
    # Optimization: Cap 100 top CF: Reduce Ram usage/ crash
    if (j %% 100 == 0) {
      gc()
    }
    utils::setTxtProgressBar(pb, j)
  }
    close(pb)
  
  # cleanup
  gc()
  return(cf_scores)
}
```

```{r}
# Recommendation Main
recommend_mood <- function(
  mood_label,
  k = 20,
  k_neighbors = 30,
  w_cf = 0.8,
  w_pop = 0.2
) {
  # Get initial score and rank before CF
  centroid_info <- get_full_centroid_info(mood_label)
  
  # CF scores (mood-based)
  cf_scores <- compute_cf_scores(mood_label, k_neighbors)
  
  # Popularity scaling
  pop_scaled <- compute_pop_scaled(df$popularity)
  
  # Final score (weighted sum)
  final_score <- w_cf * cf_scores + w_pop * pop_scaled
  
  # Merging
  output <- df %>%
    
    # Bind the centroid info and scores
    bind_cols(centroid_info) %>%
    mutate(
      cf_score = cf_scores,
      pop_scaled = pop_scaled,
      final_score = final_score,
      # Calculate final rank (after CF and weighting)
      rank_after_cf = rank(desc(final_score), ties.method = "min")
    ) %>%
    
    # Select only final top K song
    arrange(desc(final_score)) %>%
    slice(1:k) %>%
    select(
      
      # Comparision
      track_name, artists, 
      original_centroid_score, rank_before_cf, 
      cf_score, final_score, rank_after_cf,
      
      # Supporting Columns
      track_genre, emotion_label, popularity, pop_scaled
    )

  return(output)
}
```

```{r}
# Happy
happy_recs <- recommend_mood("happy", k = 20)
print(head(happy_recs))

```

```{r}
library(ggplot2)
library(dplyr)

# PCA  
pca_res <- prcomp(weighted_feats, scale = FALSE)

# Build pca dataframe
pca_df <- data.frame(
  PC1 = pca_res$x[,1],
  PC2 = pca_res$x[,2],
  cluster = as.factor(df$emotion_cluster),
  emotion = df$emotion_label   # uses your manual_map
)

# Cluster centroids for labels
centroids <- pca_df %>%
  group_by(cluster, emotion) %>%
  summarise(
    PC1 = mean(PC1),
    PC2 = mean(PC2),
    .groups = "drop"
  )

# Plot
ggplot(pca_df, aes(x = PC1, y = PC2, color = emotion)) +
  geom_point(alpha = 0.3, size = 1) +
  scale_color_manual(values = c(
    "happy"   = "#FFD700",
    "sad"     = "#1f77b4",
    "angry"   = "#d62728",
    "neutral" = "#7f7f7f"
  )) +
  geom_label(
    data = centroids,
    aes(label = emotion),
    color = "black",
    fill = "white",
    size = 4,
    fontface = "bold",
    label.r = unit(0.15, "lines")
  ) +
  theme_minimal(base_size = 14) +
  labs(
    title = "PCA Scatterplot",
    subtitle = "manual_map: ('1'='sad','2'='angry','3'='neutral','4'='happy')",
    x = "PC1",
    y = "PC2",
    color = "Emotion"
  )
```

